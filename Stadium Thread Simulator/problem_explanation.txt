Explain: How their solution avoids depriving the different sports player types of the field (avoiding thread
starvation).

To prevent thread starvation, we implemented mutex locks, condition variables, and specific coordination mechanisms between the different sports player types. Each sport (baseball, football, and rugby) is assigned its own lock (bb_lock, fb_lock, r_lock) to manage access to the respective threads. These locks ensure that only one thread can modify the team and field status at any given time, effectively preventing race conditions and thread starvation. Condition variables (bb_cond, fb_cond, r_cond) are used to control when threads can proceed. These variables ensure that players from each sport wait until a field slot becomes available and that, once a game ends, other threads are notified to create teams or begin playing. We use an additional lock called lock and condition variable called f_cond to specifically control threads entering and using the field, since this pertains to modification of the field structure that we used to contain overall information about all the games played and all the players tracked. Threads use pthread_cond_broadcast() with their respective sport condition variable to notify threads of the same sport when teams/pairs are ready to be formed/when they may start forming again after a game, and additionally with the overall f_cond to notify other sports about an empty field when a current game concludes. Threads use pthread_cond_wait() with their respective sport condition variable to wait for their teams to form, and with f_cond to pause until the field is available to them again, either because they were previously playing or because an ongoing game is taking place. This ensures that generally, the same sport should not be taking up too much time on the field. To further enhance fairness, we track how many games each sport has played using a current_sport and a last_sport variable, which keeps allows us to determine 
which sports went last and which sport is currently playing. This is particularly useful in the case of rugby, where we also track how many times rugby played in a row, and limit this to about 2 times. This is because we recognize that rugby (due to it's parallelism requirement) may either have all of its threads or only a few of its threads pile into a game on the field at a time (depending on when rugby players are ready or whether other sports are waiting to play), and limiting the number of times rugby may play in a row to this amount ensures that it gets its chances, but not too many.

This design increases fairness by ensuring that no single sport monopolizes the field, reducing the likelihood of thread starvation. Additionally, we ensure that no player monopolizes their team. Each player can only participate in a maximum of two games, and exits after reaching this number. 


Explain: The kind of test cases would be most effective for identifying potential synchronization issues? Please share at least two cases.

The most effective test cases for identifying synchronization issues would involve using various seed values, such as 0 and a very large number. These two extreme values help test the simulation’s ability to handle both minimal and maximal conditions. The seed value 0 ensures that the system behaves predictably in the simplest case, while a large seed value tests the system’s ability to handle larger, more complex scenarios. These cases help show potential flaws in synchronization and ensure that the system works as intended under varying conditions. In the output text, we've included test cases of for seeds of 0, 1234556789 and the benchmark 1234. 