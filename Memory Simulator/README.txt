Memory Simulator
March 2025
Palina Pyachynskaya and Cindy Wu

All source code (including .h and .c files and disk.txt) are included in source_code.zip. Input files used to test the program are provided in input_tests.zip, and the output for each respective input file is provided in output_tests.zip. The first 3 input/output files correspond to test cases provided in the given starting code and the project instructions. The makefile to compile the program is provided separately. To compile the project, make sure all source code and the makefile are in the same directory, and run make all. To run the executable, enter the command ./mmu, after which instructions will be prompted. 

PLEASE NOTE: our implementation puts in the freeFrames array as an external function in memsim.h in order to allow us to be able to access it.

ALSO PLEASE NOTE: our output will not match expected output from the first set of testing files provided to us in the starter code due to some differences in implementing eviction (explained later below). Furthermore, in regards to the expected output for the 2nd set of testing files given to us in the starter code, we will have different output due to some additional error logging that we have implemented (however, content-wise it's the same).

This C project was built off of the starter code provided by Professor Taneja. We implemented all the provided functions and implemented several helper functions/data structures, which we will now discuss.

We decided to keep track of disk space using an array of ints called swapSlots, containing up to 32 slots. We revised the ptRegister struct to also track if a page table is present (1 representing it being in physical memory, and 0 representing it being on the disk) and its swap slot number once it is swapped to the disk. We revised the PTE structure to contain the valid, protection, present and referenced bits (though we never ended up using the referenced bit, only the present bit and valid bit to properly find pages to swap/evict) as unsigned ints, and 4 extra bits to be allocated just in case (and to make it easier to picture the suggestion of using 3 bytes per page table entry). We implemented an additional helper called PT_PageTableIsPresent, which we use particularly in PT_Evict and PT_getRootPtrRegVals to swap in a page table if one of its pages in physical memory needs to be swapped out, but also needs to update its PTE first. We also created a getswapSlot helper function (which iterates over and marks slots of the swapSlots array as free or not free) to make it convenient to obtain a swap slot on the disk whenever we are ready to swap out a page table or page from physical memory. 

The bulk of our logic is in PT_SwapIn, another helper that we implemented to handle the swapping in of pages and page tables. PT_SwapIn is called with a pid and a VPN, because it is important to keep track of the process that owns a page table if we are to find it and make updates to it. When we intend to switch in a page table (which occurs if a page needs to be swapped out, but its page table is absent from physical memory, or when its the turn of a page table frame to be evicted), VPN is called with -1. Next, we use Memsim_FirstFreePFN to get the first free frame; if there is none, PT_Evict is called to free a frame. Once we get a free frame, we get the swap slot of the page table being requested (since it is actually on the disk), and then read in the page table from the swap file (disk.txt), using the swapSlot*PAGE_SIZE as an offset to seek where the proper information is. We read this info into physmem array at the address of the frame returned by Memsim_FirstFreePFN, update all the ptRegVals fields to signify the page table is in memory again, and mark that frame as used. In the case where PT_SwapIn is not called with VPN==-1, we know that we have to swap in a page. Here, we will call PT_GetRootPtrRegVal to ensure the page's page table is in memory, declare all the bytes of the page table entry we are looking for (using the VPN*3 as an offset into the physmem array), find a free frame using the same approach as described above, and again seek into and read from the swap file into memory. Finally, the PTE is updated with new flags (where present bit is now set to 1, since the page is in memory) and new page frame number, rather than the swap slot that we have it store when a page is swapped out.

To evict a frame, we attempted to implement a RR approach, where the counter keeping track of which frame to evict (called pageToEvict) is advanced after a successful eviction of a not-free frame (which is tracked by the freeFrames array), looping around back to 0 once 3 is reached due to modulo by PAGE_NUMBER. An important thing to note is that RR does not always cycle through the frames, which can be depicted in our output files. Thus, our output does not completely match the test cases provided by the project, even though we still map, store and load values as in the expected output. Regardless, every frame still gets to be evicted throughout a sufficiently long test run. In PT_Evict, an outer loop iterates over the number of physical pages (we found this necessary to ensure that eviction continues trying to occur even after the first page table is swapped out, rendering it difficult to evict its page; this was an issue we really struggled with initially). Within this loop, we identify whether the current frame is free already or not, and if it's not, we go into two separate for loops to handle the case for evicting a page table, and the case for evicting a regular page. We know we have to evict a page table if it is present in memory and if the address of the current frame that we're looking at is equal to the ptStartPA field of that page table. From there, we obtain a swap slot, write to the disk at the offset of the returned swap slot * PAGE_SIZE, and update the page table info to be not present and store its swap slot. We also set the memory in the physmem array in the frame to 0 (clearing). The next frame to evict is then incremented. 

If these conditions are not met, we know that we are evicting a regular page instead, which means we first ensure that that page's page table is bought into memory. We then introduce yet another nested loop to iterate over the total possible number of virtual pages (4) and thus find all the page table entries present in physical memory at the moment. If a match is found between the current frame we are looking to evict and the page frame number of some entry, we know that that page is within that frame. Thus, we will get a swap slot, seek and write to the swap file at that offset, and then update the PTE of the evicted page by using the found VPN*3 as an offset (combined with the starting address of the frame) into memory. We set the memory in the physmem array in the frame to 0 (clearing). Finally, the current frame is marked as free and the counter to evict the next page is advanced.

With this method, we are able to swap in and evict pages within the map, load and store instructions. In brief, map first checks if a given page table exists and if a given virtual page for some process was already mapped. This is meant to catch the instructions that update permissions for maps with the same process/VA but different protection bits, as well as to prevent map instructions with the the same protection bits for the same virtual pages from reassigning the read-write permission. In the case that a page table does not exist, we attempt to find a free frame to map the page table into, and if we can't, we call PT_Evict to free a frame. If the page table is not in memory, we swap it in. Finally, if a page table already in memory, we find a frame to assign its virtual page to, and we can't find a frame, we call PT_Evict to get us one.

In store, we find the offset using the passed in virtual address % PAGE_SIZE, and then call MMU_TranslateAddress to translate that address. If the translation fails, this means we might have to swap in a page, which we attempt to do. Then, we retry with the MMU_TranslateAddress function again, after which we index into the physmem array at that returned physical address to store value_in.

In load, we get the offset similarly to the store function. Again, we translate the address, and if the page is not in memory, we swap it in with PT_SwapIn (note that here we call the VPN parameter with VPN(va)). Finally, given the returned physical address, we extract the value stored in physmem[pa] and return it as the value that was found at the passed in virtual address.

In doing so, our program mostly efficiently handles fair eviction and swapping of pages in physical and virtual memory, including mapping, loading and storing with multiple processes in action at the same time (as can be seen from our provided test files).

Used for CS 3013 Operating Systems.